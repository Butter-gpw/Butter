# C++核心编程

本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓



**这篇东西是看B站黑马程序员视频自己跟着写的**

## 1 内存分区模型

C++程序在执行时，将内存大方向划分为**4个区域**

- 代码区：存放函数体的二进制代码，由操作系统进行管理
- 全局区：存放全局变量和静态变量以及常亮
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收







**内存四区意义：**

不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程





### 1.1 程序运行前

​		在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域

​		代码区：

​				存放CPU执行的机器指令

​				代码区是共享的，共享的目的是对于频繁被执行的程序，只需在内存中有一份代码即可

​				代码区是只读的，使其只读的原因是防止程序员意外地修改了它的指令

​		全局区：

​				全局变量和静态变量存放在此

​				全局区还包括了常量，字符串常量和其他常量也存放在此

​				该区域的数据在程序结束后由操作系统释放



​		总结：

- C++在程序中运行钱分为全局区和代码区
- 代码区特点是共享和只读
- 全局区中存放全局变量、静态变量、常量
- 常量区中存放const修饰的全局变量和字符串变量



### 1.2 程序运行后

栈区：

​		由编译器自动分配施放，存放函数的参数值，局部变量等

​		注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放



堆区：

​		由程序员分配释放，若程序员不释放，程序结束时由操作系统回收

​		在C++中主要利用new在堆区开辟内存

### 1.3 new操作符

C++中利用new操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete



语法：new 数据类型

利用new创建的数据会返回该数据对应类型的指针



示例：开辟数组

```c++
int a;
int main() {
    int* arr= new int[10];
    delete [] arr;
    
    return 0；
}
```





## 2 引用

### 2.1 引用的基本作用

**作用：**给变量起名字

**语法：**数据类型 &别名 = 原名



### 2.2 引用注意事项

- 引用必须初始化
- 引用在初始化后，不可以改变



### 2.3 引用做函数参数

**作用：**函数传参时，可以利用引用的技术让形参修饰实参

**优点：**可以简化指针修改实参

 

### 2.4 引用做函数返回值

作用：引用是可以作为函数的返回值存在的



注意：不要返回局部变量应用

用法：函数调用作为左值





### 2.5 引用的本质

本质：**引用的本质在C++内部实现是一个指针常量**





### 2.6 常量引用

**作用：**常量引用主要用来修饰形参，防止误操作



在函数形参列表中，可以加const修饰形参，防止形参改变实参



## 3 函数提高

### 3.1 函数默认参数

在C++中，函数的形参列表是可以有默认值的。



```c++
int f（int a=5,int b=10,int c=10）{
	return a+b+c;
}
```

如果某个位置参数有默认值，那么从这个位置后，从左往右都需要有默认值

如果函数声明有默认值，函数实现的时候就不能有默认参数



### 3.2 函数站位参数

C++中函数的形参列表里可以有站位参数，用来做占位，调用函数时必须填补该位置

占位参数还可以有默认参数





### 3.3 函数重载

#### 3.3.1 函数重载概述

**作用：**函数名可以相同，提高复用性



**函数重载满足条件：**

- 同一个作用域下
- 函数名称相同
- 函数参数**类型不同** 或者 **个数不同** 或者 **顺序不同**



**注意：**函数的返回值不可以作为函数重载的条件



#### 3.3.2 函数重载注意事项

- 引用作为重载条件
- 函数重载碰到函数默认参数



```c++
void func(int &a){  //输入变量的时候调用
    cout<<"func（int&a）"<<endl;
}

void func(const int &a){   //输入常数的时候调用
    cout<<"func（int&a）"<<endl;
}

void func2(int a, intb = 10){ //无法调用，出现二义性，尽量避免
    cout<<"func2（int a, intb）"<<endl;
}

void func2(int a){ //无法调用，出现二义性，尽量避免
    cout<<"func2（int a）"<<endl;
}
```





## 4 类和对象

C++面向对象的三大特性为：封装、继承、多态



C++认为万事万物皆为对象，对象上有其属性和行为





### 4.1 封装

#### 4.1.1 封装的意义

封装是C++面向对象三大特征之一

- 将属性和行为作为一个整体，表现生活中的失误
- 将属性和行为加以权限控制

**封装意义一：**

​	在设计类的时候，属性和行为写在一起，表现事物



**封装意义二：**

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：

1.public  公共权限    类内可以访问  类外可以访问

2.protected 保护权限  类内可以访问  类外不可以访问  儿子可以访问父亲中的保护内容

3.private  私有权限  类内可以访问  类外不可以访问  儿子不可以访问父亲中的私有内容





#### 4.1.2 struct和class区别

在C++中struct和class的区别就在于默认的访问权限不同

区别：

- struct 默认权限为公共
- class 默认权限为私有





#### 4.1.3 成员属性设置为私有



**优点1**：将所有成员属性设置为私有，可以自己控制读写权限

**优点2**：对于写权限，我们可以检测数据的有效性





### 4.2 对象的初始化和清理

#### 4.2.1 构造函数和析构函数

​	一个对象或者变量没有初始状态，对其使用后果是未知

​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题



C++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器提供的构造函数和析构函数是空实现**



- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。





构造函数语法：`类名(){}`

1. 构造函数，没有返回值也不谢void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造函数，无须手动调用，而且只会调用一次



析构函数语法：`~类名(){}`

1. 析构函数，没有返回值也不谢void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次



```c++
class person{
public:
    person(){
        cout<<"构造函数调用"<<endl;    }
    
    ~person(){
        cout<<"析构函数调用"<<endl;
    }
};
```





#### 4.2.2 构造函数的分类及调用

两种分类方式：

​	按参数分为：有参构造和无参构造

​	按类型分为：普通构造和拷贝构造

三种调用方式：

​	括号法

​	显示法

​	隐式转换法



```c++
class person{
public:
    person(){
        cout<<"无参构造函数调用"<<endl;    }
    
    person(int a){
        age = a;
        cout<<"有参构造函数调用"<<endl;  
    }
    //拷贝构造函数
    person(const person &p){
        //将传入的人身上的所有属性，拷贝到我身上
       
        age = p.age;
    }
    
    
    ~person(){
        cout<<"析构函数调用"<<endl;
    }
    
    int age;
};

//调用
void test01(){
    //括号法
    person p1;
    person p2(10);//有参构造函数调用
    
    //显式法
    
    person p4 = person(10);
    
    //隐式转换法
    person p5 = 10;
    
}
```





#### 4.2.3 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况

- 使用一个已经创建完毕的对象来初始化一个新对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象





#### 4.2.4 构造函数调用规则

默认情况下，C++编译器至少给一个类添加3个函数

1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性值进行拷贝



构造函数调用规则如下：

- 如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造
- 如果用户定义拷贝构造函数，C++不会在提供其他构造函数





#### 4.2.5 深拷贝与浅拷贝



深拷贝是面试经典问题，也是常见的一个坑



浅拷贝：简单的复制拷贝操作



深拷贝：在堆区重新申请空间，进行拷贝操作





#### 4.2.6 初始化列表

**作用：**

C++提供了初始化列表法，用来初始化属性



**语法：**`构造函数（）：属性1（值1）属性2（值2）....{}`

```c++
class person{
    public:
    person(int x,int b):p_a(x),p_b(b){}
    
    p_a;
    p_b;
}
```



#### 4.2.7 类对象作为类成员



C++类中的成员可以是另一个类的对象，我们称该成员为对象成员



当其他类对象作为类成员，构造时候先构造类对象，再构造自身，析构的顺序与构造相反





#### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，成为静态成员

静态成员分为：



- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - 类内声明，类外初始化
- 静态成员函数
  - 所有对象共享同一个函数
  - 静态成员函数只能访问静态成员变量





### 4.3 C++对象模型和this指针



#### 4.3.1 成员变量和成员函数分开存储



在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上



空对象占用内存空间为1B，为了区分空对象占内存的位置

非空的就按数据类型的大小如int 4B





#### 4.3.2 this指针概念

通过4.3.1我们知道在C++成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是多个同类型的对象会公用一块代码

那么问题是：  这一块代码是如何区分那个对象调用自己的呢？



C++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**



this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可

this指针的本质，是指针常量，指针的指向是不可以修改的



this指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用return *this





#### 4.3.3 空指针访问成员函数



C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针



如果用到this指针，需要加以判断保证代码的健壮性





#### 4.3.4 const修饰成员函数

**常函数：**

- 成员函数**后**加const后我们称这个函数为常函数，修饰this指针
- 常函数不可以修改成员属性
- 成员属性声明时加关键字mutable后，在常函数中依然可以修改



**常对象：**const person

- 声明对象前加const称该对象为常对象
- 常对象只能调用常函数



### 4.4 友元

友元的目的就是让一个函数或者类，访问另一个类中私有成员

友元的关键字为friend



友元的三种实现：

- 全局函数做友元
- 类做友元
- 成员函数做友元



```c++
class goodgay{
public:
    void visit(){}
};
class Building{
    friend void goodfriend(Building *building);//函数是building的好朋友 可以访问building中的私有成员
    friend class goodgay;//类是building的好朋友 可以访问building中的私有成员
    friend void goodgay::visit();//goodgay类中的visit函数是building的好朋友 可以访问building中的私有成员

public:
    string sitting_room;
private:
    string beed_room;//可以被goodfriend函数访问
};
```





### 4.5 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型



#### 4.5.1 加号运算符重载

作用：实现两个自定义数据类型相加的运算



```c++
class Person{
public:
    //类内方法实现运算符重载类内方法
    Person operator+(Person &P) {
        Person temp;
        temp.m_A = this->m_A + P.m_A;
        temp.m_B = this->m_B + P.m_B;
        return temp;
    }


    int m_A=10;
    int m_B=10;

};

//全局函数实现运算符重载
Person operator+(Person &p1,Person &p2){
    Person temp;
    temp.m_A = p1.m_A + p2.m_A;
    temp.m_B = p1.m_B + p2.m_B;

    return temp;
}
```



#### 4.5.2 左移运算符重载

作用：可以输出自定义数据类型

```C++
class Person{
public:
    //通常不会利用成员函数重载<<运算符，因为无法实现cout在左侧

    int m_A=10;
    int m_B=10;

};

//只能利用全局函数重载
ostream & operator<<(ostream &cout, Person &p){
    cout<<"m_A="<<p.m_A<<" m_B="<<p.m_B;
    return cout;
}
```





#### 4.5.3 递增运算符重载



作用：通过重载递增运算符，实现自己的整形数据



```C++
class MyInteger{
    friend ostream & operator<<(ostream& out, MyInteger myint);

public:
    MyInteger(){
        m_Num = 0;
    }
    //前置++
    MyInteger& operator++(){//前置++要返回自身引用以便可以连续增加同一个数值
        m_Num++;
        return *this;
    }

    //后置++
    MyInteger operator++(int){//后置应用返回的是值
        //先返回
        MyInteger temp = *this;//先记录本身的值，然后让本身的值加一
        m_Num++;
        return temp;
    }
    int m_Num;

};

ostream & operator<<(ostream& out,MyInteger myint){
    cout<<myint.m_Num;
    return out;
}
```



总结：前置++返回的是引用，后置++返回的是值





#### 4.5.4 赋值运算符重载



C++编译器至少给一个类添加四个函数

1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符operator=，对属性进行值拷贝



如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题



```c++
class Person{
public:
    Person(int age){
        m_Age = new int(age);//将年龄数据开辟到堆区
    }

    //重载赋值运算符
    Person& operator=(Person &p){//为了可以连续赋值返回自身
        if (m_Age!= nullptr){
            delete m_Age;
            m_Age = nullptr;
        }
        //编译器自身提供的是浅拷贝
        //m_Age = p.m_Age;

        //提供深拷贝 解决浅拷贝问题
        m_Age = new int(*p.m_Age);

        return *this;
    }
    
    ~Person(){
        if(m_Age != nullptr){
            delete m_Age;
            m_Age = nullptr;
        }
    }
    
    int *m_Age;
};
```





#### 4.5.5 关系运算符重载

**作用：**重载关系运算符，可以让两个自定义类型进行对比操作





#### 4.5.6 函数调用运算符重载

- 函数调用运算符()也可以重载
- 由于重载后使用的方式非常像函数的调用，因此成为仿函数
- 仿函数没有固定写法，非常灵活





### 4.6 继承

**继承是面向对象三大特征之一**



#### 4.6.1 继承的基本语法

语法：`class 子类: 继承方式 父类`

class A:public B；

A类成为子类 或 派生类

B类成为父类 或 基类



派生类中的成员，包含两大部分：

一类是从基类继承过来的，一类是自己增加的成员。

从基类继承过来的表现起共性，而新增的成员体现了其个性。





#### 4.6.2 继承方式

语法：`class 子类: 继承方式 父类`



继承方式一共有三种：

- 公共继承
- 保护继承
- 私有继承





#### 4.6.3 继承中的对象模型

**问题：**从父类继承过来的成员，哪些属于子类对象中？

结论：父类中的私有成员也被子类继承下去，只是被编译器隐藏了



#### 4.6.4 继承中构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数



问题：父类和子类的构造函数和析构顺序是谁先谁后

先构造父类，再构造子类，析构的顺序与构造的顺序想反





#### 4.6.5 继承同名成员处理方式

问题：当子类与父类出现同名的成员如何通过子类对象，访问到子类或父类中同名的数据呢？



- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域   
-  `子类.父类:: 成员`



总结：

1. 子类对象可以直接访问到子类中同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数





#### 4.6.6 继承同名静态成员处理方式

问题：继承中同名的静态成员在子类对象上如何进行访问？



静态成员和非静态成员出现同名，处理方式一致



- 访问子类同名成员，直接访问即可
- 访问父类同名成员，需要加作用域



总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和通过类名）



#### 4.6.7 多继承语法

C++允许一个类继承多个类



语法`class 子类： 继承方式 父类1， 继承方式 父类2...`



多继承可能会引发父类中有同名成员出现，需要加作用域区分



**C++实际开发中不建议使用多继承**





#### 4.6.8 菱形继承



**菱形继承概念：**

​	两个派生类继承同一个基类

​	又有某个类同时继承两个派生类

​	这种继承成为菱形继承，或者砖石继承





菱形继承问题：

1. 产生二义性
2. 其实只需要一份数据



利用虚继承解决菱形问题：关键字virtual







### 4.7 多态

#### 4.7.1 多态的基本概念



**多态是C++面向对象三大特性之一**

多态分为两类

- 静态多态：函数重载 和运算符重载属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态



静态多态和动态多态区别

- 静态多态的函数地址早绑定 - 编译阶段确定函数地址
- 动态多态的函数地址晚绑定 - 运行阶段确定函数地址





```c++
class Animal{
public:
    void speak(){
        cout<<"动物在说话"<<endl;
    }
};

class Cat: public Animal{
public:
    void speak(){
        cout<<"猫在说话"<<endl;
    }
};


void dospeak(Animal& animal){
    animal.speak();
}


void test01(){
    Cat cat;
    dospeak(cat); //会输出动物在说话
}
```





```c++
class Animal{
public:
    virtual void speak(){
        cout<<"动物在说话"<<endl;
    }
};

class Cat: public Animal{
public:
    void speak(){
        cout<<"猫在说话"<<endl;
    }
};


void dospeak(Animal& animal){
    animal.speak();
}


void test01(){
    Cat cat;
    dospeak(cat);//会输出猫在说话
}
```



动态多态满足条件：

1. 有继承关系
2. 子类重写父类的虚函数



动态多态使用：

1. 父类的指针或者引用执行子类对象

重写：函数返回值类型 函数名 参数列表 完全一致



![](C:\Users\Butter\Desktop\虚函数继承原理.png)





#### 4.7.2 多态案例—计算机类



案例描述：

分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算机类



多态的优点：

- 代码组织结构清晰
- 可读性强
- 利于前期和后期的扩展和维护



开闭原则：对扩展进行开放，对修改进行关闭





```c++
class Calculator{
public:
    virtual int getResult(){
        return 0;

    }
    int m_Num1;
    int m_Num2;
};


class AddCalculator:public Calculator{
public:
    int getResult(){
        return m_Num1+m_Num2;
    }
};


class SubCalculator:public Calculator{
public:
    int getResult(){
        return m_Num1-m_Num2;
    }
};


class MulCalculator:public Calculator{
public:
    int getResult(){
        return m_Num1*m_Num2;
    }
};


void test01(){
    Calculator * abc = new AddCalculator;
    abc->m_Num1 = 10;
    abc->m_Num2 = 20;
    cout<<abc->getResult()<<endl;
    delete abc;
}
```







#### 4.7.3 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容



因此可以将虚函数改为纯虚函数



纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0；`



当类中有了纯虚函数，这个类也成为抽象类



抽象类特点：

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类



```c++
class Calculator{
public:
    virtual int getResult()=0；
    int m_Num1;
    int m_Num2;
};

```





#### 4.7.4 多态案例二-制作饮品



```c++
class AbstractDrinking{
public:
    virtual void Boil() = 0;

    virtual void Brew() = 0;

    virtual void PourInCup() = 0;

    virtual void PutSomething() = 0;

    void makeDrink(){
        Boil();
        Brew();
        PourInCup();
        PutSomething();
    }

};


class Tea: public AbstractDrinking{
public:
    virtual void Boil(){
        cout<<"煮水"<<endl;
    }

    virtual void Brew() {
        cout<<"冲泡"<<endl;
    };

    virtual void PourInCup() {
        cout<<"倒入杯中"<<endl;
    };

    virtual void PutSomething(){
        cout<<"不加东西"<<endl;
    };

};

void dowork(AbstractDrinking* drinking){
    drinking->makeDrink();
    delete drinking;
};


void test01(){
    dowork(new Tea);
}
```





#### 4.7.5 虚析构和纯虚析构



多态使用时，如果子类中有属性开辟到**堆区**，那么父类指针在释放时无法调用子类的析构代码



解决方式：将父类中的析构函数改为虚析构或者纯虚析构



虚析构和纯虚析构共性：

- 可以解决父类指针施放子类对象
- 都需要有具体的函数实现



虚析构和纯虚析构的区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象



虚析构语法：

`virtual ~类名(){}`

纯虚析构语法：
`virtual ~类名()=0；`

`类名::~类名(){}`



```c++
class Animal{
public:
    Animal(){
        cout<<"Animal构造函数调用"<<endl;

    }
    virtual void speak() = 0;


    //析构函数加上virtual关键字变成虚析构函数
//    virtual ~Animal(){
//        cout<<"Animal虚析构函数调用"<<endl;
//    }
    virtual ~Animal() = 0;
};

Animal::~Animal() {
    cout<<"Animal纯虚析构函数调用"<<endl;
}


class Cat: public Animal{
public:
    Cat(string name){
        cout<<"Cat构造函数调用"<<endl;
        m_Name = new string(name);
    }

    virtual void speak(){
        cout<<"小猫在说话"<<endl;
    }

    ~Cat(){
        cout<<"Cat析构函数调用"<<endl;
        if(this->m_Name != nullptr){
            delete m_Name;
            m_Name = nullptr;
        }
    }

public:
    string *m_Name;
};

void test01(){
    Animal* animal = new Cat("Tom");
    animal->speak();

    delete animal;
};
```



总结：

1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
3. 拥有纯虚析构函数的类也属于抽象类







## 5 文件操作



程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放

通过文件可以将数据持久化

C++中对文件操作需要包含头文件<fstream>



文件类型分为两种：

1. 文本文件   -文件以文本的ASCII码形式存储在计算机中
2. 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们



操作文件的三大类：

1. ofstream：写操作
2. ifstream：读操作
3. fstream：读写操作



### 5.1 文本文件

#### 5.1.1 写文件

1. 包含头文件

   #include<fstream>

2. 创建流对象

   ofstream ofs；

3. 打开文件

   ofs.open("文件路径"，打开方式);

4. 写数据

   ofs<<"写入的数据";

5. 关闭文件

   ofs.close();



文件打开方式：

| 打开方式    | 解释                       |
| :---------- | -------------------------- |
| ios::in     | 为读文件而打开文件         |
| ios::out    | 为写文件而打开文件         |
| ios::ate    | 初始文件：文件尾           |
| ios::app    | 追加方式写文件             |
| ios::trunc  | 如果文件存在先删除，在创建 |
| ios::binary | 二进制方式                 |

**注意：**文件打开方式可以配合使用，利用|操作符





#### 5.1.2 读文件



读文件与写文件步骤类似，但是读取方式相对比较多



读文件步骤如下：

1. 包含头文件

   #include<fstream>

2. 创建流对象

   ifstream ifs；

3. 打开文件

   ifs.open("文件路径"，打开方式);

4. 写数据

   四种方式读取

5. 关闭文件

   ifs.close();



```c++
void test01(){
    ifstream ifs;
    ifs.open("test.txt",ios::in);
    if(!ifs.is_open()){
        cout<<"文件打开失败了"<<endl;
        return;
    }


    char buf[1024] = {0};
    //第一种方法
    while (ifs>>buf){
        cout<<buf<<endl;
    }

    //第二种方法
    while (ifs.getline(buf,sizeof(buf))){
        cout<<buf<<endl;
    }

    //第三种方法
    string buf1;
    while (getline(ifs,buf1)){
        cout<<buf1<<endl;
    }

    //第四种方法
    char c;
    while ((c = ifs.get())!=EOF){
        cout<<c;
    }

    ifs.close();
}
```





### 5.2 二进制文件

以二进制的方式对文件进行读写操作

打开方式要指定为`ios::binary`



#### 5.2.1 写文件

二进制方式写文件主要利用流对象调用成员函数write

函数原型：`ostream& write(const char * buffer,int len);`

参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数





#### 5.2.2 读文件

二进制方式读文件主要利用流对象调用成员函数read

函数原型：`ostream& read(char * buffer,int len);`

参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数